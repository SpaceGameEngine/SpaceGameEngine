# Space Game Engine
## 错误处理
### 概念
&emsp;&emsp;错误的检查分为两种:`Assert`和`Check`。两者的区别在于`Assert`只在`Debug`模式下才进行检查，而`Check`是不论`Debug`还是`Release`模式都进行检查的。  

&emsp;&emsp;因此`Assert`和`Check`两者有着完全不同的用处。
* `Assert`是用来检查条件的。在一个函数中`Assert`通常放在函数的开头，用来检查函数运行的条件（如参数的合法性、环境的配置是否正确等）。
* `Check`是用来检测无法预测的运行时错误的。在一个函数中其通常被放置在我们无法预测结果的函数调用（比如第三方函数调用）的后面用来检查函数调用返回的结果是否符合我们的需要。

### 概念的完备性分析
&emsp;&emsp;据我目前所知，以上的这种处理错误的方法是可以做到处理大部分程序所产生的错误的。且在`Release`模式生成时，没必要的检测(`Assert`)都被删去，每个错误检测都是不会重复的。具体论证如下：

&emsp;&emsp;我们可以把整个程序运行的过程看做是一系列函数调用的过程。这些函数都有参数（包括函数运行的环境），这些参数分为两种：**编译期确定的**和**运行时确定**的。编译期确定的参数都可以在`Debug`模式下被`Assert`检查，如果这些固定不变的参数在`Debug`模式下没有问题的话，那么在`Release`模式生成时，尽管`Assert`已经没有了，但这些固定不变的参数已经确定是正确的了，所以其在`Release`模式下也必然没有问题（前提是这些参数不会因生成模式的不同而发生变化）。所以，编译期就已经确定的参数的检查就完成了。再来看，运行时的错误。我们可以明确一点：运行时，我们自己的代码在大多数情况下是可控可预测的，所以基本不会出错（除了涉及到多线程的时候），大多数的运行时错误都出在第三方函数调用上。所以我们只需要在调用第三方函数后去用`Check`检查结果是否有错即可。当然，值得注意的是，在`Debug`模式下，`Assert`和`Check`的功能有些重复，因为`Assert`也会检查运行时传来的函数参数，但是没有关系，在`Release`模式下生成时，这些重复的检查都会被删去。

### 从概念到实践
&emsp;&emsp;如果完全按照概念来做错误处理，固然能够将大部分的错误都妥善地处理好。但是，随之而来的，是严峻的性能问题。尽管`Assert`在`Release`模式下没有作用，不带来性能负担。但是如果每调用一次第三方函数就用`Check`检查一次，所带来的负担还是很大的。所以，在实践过程中我们可以遵循以下规则来进行错误处理：  
1. 对每个函数的参数及所需的环境条件进行`Assert`检查：这不仅仅可以检查编译期的参数，同时在运行时（`Debug`模式下），其也可以检查函数调用的运行时的参数，但函数过程中的问题就无能为力了。
2. 对于那些我们可以预测结果的第三方函数调用就不用`Check`进行检查了，如数学计算函数等。对于那些有着还算好用的错误/异常处理的第三方函数调用，如`STL`等，我们可以信任他们的错误处理机制，不进行`Check`。但对于那些检测错误及其麻烦的，如系统调用等，我们要用`Check`进行检查。

### 使用`SpaceGameEngine`中的错误处理机制
#### 抛出错误
&emsp;&emsp;如果你直接`include`了`Error.h`的话那么就可以使用`SGE_ASSERT`和`SGE_CHECK`这两个宏来进行上文所说的`Assert`和`Check`了，两个宏的参数都为`(expr,error_type,error_level)`。又或是直接使用`Assert...`和`Check...`系列函数来直接判断（不需要自己写用于判断的表达式）。

&emsp;&emsp;但是如果代码被`Error.h`使用的话（引擎内的代码），就不能直接`#include "Error.h"`了。则必须通过头文件`#include "ForwardDefination.hpp"`、源文件`#include "Error.h"`的方式以使用**前置声明**来进行错误处理，且在这种情况下，头文件中不能使用`SGE_ASSERT`和`SGE_CHECK`这两个宏（因为没有`Error`子类和`ErrorLevel`的声明），而只能使用`Assert...`和`Check...`系列函数的前置声明了。

#### 添加错误类型
&emsp;&emsp;如果你想要加入你自己的错误类型，你可以直接写个类继承于`Error`，然后在这个类的构造函数中重新给`m_ErrorMessage`赋值即可。其后，你也可以添加一些封装好的`Assert...`和`Check...`函数。如果这个错误类型将用于引擎内部的话，你还应该将这些你自己定义的`Assert...`和`Check...`函数的声明复制到`"ForwardDefination.hpp"`中以提供必要的前置声明以供使用。